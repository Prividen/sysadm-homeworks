# Домашняя работа по занятию "4.1. Командная оболочка Bash: Практические навыки"

> 1. Есть скрипт ...
> Какие значения переменным c,d,e будут присвоены?

$c: `a+b`<br>
$d: `1+2`<br>
$e: `3`<br>

>  Почему?

- В присвоении переменной `$c` `a` и `b` указаны без спецсимвола `$`, bash не считает их за переменные, и не выполняет подстановку значений. Кроме того, без магических скобочек арифметического expansion (как это по рюсски...) (`$(())`) он не будет распознавать и выполнять арифметическую операцию. Таким образом, результат присвоения - ровно та строка, которую написали - "`a+b`".
- В присвоении переменной `$d` происходит подстановка значений переменных `$a` и `$b`, но из-за отсутствия магических скобочек не происходит выполнения арифметической операции. Результат - строка "`1+2`".
- И уж в присвоении переменной `$e` происходит и подстановка значений переменных, и арифметическая операция в скобочках. Результатом получается "`3`". В принципе, в магических скобочках должно в любом случае происходить подстановка значений переменных, так что `$` там даже лишнее:
```bash
echo $((a+b))
3
```

---
> 2. На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным. В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:

В этом скрипте используется бесконечный цикл while, из которого не предусмотрено никакого выхода. Можно модифицировать скрипт, добавив к проверке if ещё ветку else с выходом из цикла. И я б ещё разумный sleep добавил между проверками, чтобы логфайл не с такой бешеной скоростью разрастался: 

```bash
while ((1==1));	do
	curl https://localhost:4757
	if (($? != 0)); then
		date >> curl.log
	else
		break
	fi
	sleep 1
done
```

---
> 3. Необходимо написать скрипт, который проверяет доступность трёх IP: 192.168.0.1, 173.194.222.113, 87.250.250.242 по 80 порту и записывает результат в файл log. Проверять доступность необходимо пять раз для каждого узла.

```bash
#! /usr/bin/env bash

TEST_IP="192.168.0.1 173.194.222.113 87.250.250.242"
TEST_PORT=80
ROUNDS=5
LOGFILE="log"

echo "Check hosts $TEST_IP for $ROUNDS times:" > $LOGFILE
for i in $(seq 1 $ROUNDS); do
	for IP in $TEST_IP; do
		CHECK_RESULT="Check round ${i}. Host ${IP} is: "
		curl -I -m 2 -s ${IP}:${TEST_PORT} > /dev/null

		if [ $? == 0 ]; then
			CHECK_RESULT="${CHECK_RESULT} AVAILABLE."
		else
			CHECK_RESULT="${CHECK_RESULT} NOT AVAILABLE!!!11"
		fi

		echo $CHECK_RESULT >> $LOGFILE
	done
done
```
Вообще, строго говоря, "проверяет доступность IP по 80 порту" не обязательно предполагает, что там отвечает HTTP-демон, и возможно стоило бы использовать нечто вроде `netcat -z -w 1 $IP 80`. Но не будем усложнять :) 

---
> 3. Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается

```bash
#! /usr/bin/env bash

TEST_IP="192.168.0.1 173.194.222.113 87.250.250.242"
TEST_PORT=80
LOGFILE="log"
ERROR_LOGFILE="error"

echo "Check hosts $TEST_IP" > $LOGFILE
i=0
while true; do
	i=$((i+1))
	for IP in $TEST_IP; do
		curl -I -m 2 -s ${IP}:${TEST_PORT} > /dev/null

		if [ $? == 0 ]; then
			echo "Check #${i}: Host ${IP} is: AVAILABLE." >> $LOGFILE
		else
			echo "Check #${i}: Catched unavailable host: $IP" >$ERROR_LOGFILE
			break 2
		fi
	done
	sleep 1
done
```

---
> Мы хотим, чтобы у нас были красивые сообщения для коммитов в репозиторий. Для этого нужно написать локальный хук для git, который будет проверять, что сообщение в коммите содержит код текущего задания в квадратных скобках и количество символов в сообщении не превышает 30. Пример сообщения: \[04-script-01-bash\] сломал хук.

Несколько нечёткое техзадание.
- какие допустимые символы для "кода текущего задания в квадратных скобках"? Предположим, основываясь на примере, что это `0-9A-Za-z-`
- этот "код текущего задания" должен быть в начале коммит-сообщения? В конце? В любом месте? Может сообщение состоять только из этого кода? Предположим, что всё это не важно.
- количество символов в сообщении - с учётом конечного перевода строки, или чисто голое сообщение? Предположим, что с учётом `\n`. А то не пример ничего не сломает :)

Наиболее правильным хуком для таких проверок будет: `commit-msg`:
```bash
#! /usr/bin/env bash

TASK_CODE_ALLOWED_SYMBOLS="0-9A-Za-z-"
TASK_FORMAT="\[[$TASK_CODE_ALLOWED_SYMBOLS]+\]"
MSG_MAX_LENGTH=30

COMMIT_MSG=$(cat $1 |grep -v '^#')

# check for max length
if [ $(echo $COMMIT_MSG |wc -m) -gt $MSG_MAX_LENGTH ]; then
	echo "Commit failed: message too long, max $MSG_MAX_LENGTH symbols allowed, $(echo $COMMIT_MSG |wc -m) detected" >&2
	exit 1
fi

# check for [task-code]
if ! echo $COMMIT_MSG |grep -Eq "$TASK_FORMAT"; then
	echo "Commit failed: wrong format for [task-code], allowed symbols: $TASK_CODE_ALLOWED_SYMBOLS" >&2
	exit 1
fi
```