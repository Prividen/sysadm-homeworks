# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

> Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

Как докладывает команда `type cd`, команда `cd` является builtin, или встроенной командой, и исполняется командным интерпретатором.
Наверное, именно `cd` было бы трудно сделать другого типа, в отличие от какой-нибудь `echo` - смена текущей директории в дочернем процессе никак не затронет родительский, и команда окажется бесполезной.

> Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос.

 `grep -c <some_string> <some_file>`
 
> Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.

Спорно, спорно. "1999/04/23" - и не свежо. 

> Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

В Ubuntu 20.04 это systemd, в роли init. 

> Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

Нам нужно в другой сессии терминала посмотреть тамошний STDOUT: `readlink -e /proc/$$/fd/1` (или просто команда `tty`), например это будет `/dev/pts/15`.<br> 
А потом перенаправим наш STDERR именно туда: `ls file_which_not_exist 2> /dev/pts/15`  

> Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

Да, должно получиться. Пронумеруем пользователей в нашей системе:<br>
`cat -n < /etc/passwd >/tmp/numered_users`

> Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? 

Да, например `cat /tmp/numered_users > /dev/tty1`

> Сможете ли вы наблюдать выводимые данные?

Да, если на физической консоли хоста переключиться на тот самый эмулятор терминала (в данном случае CTRL-ALT-F1). И вывод в не свои консоли приходится делать от рута, а то прав не хватит. 

> Выполните команду `bash 5>&1`. К чему она приведет? 

Она приведёт к тому, что откроется новый командный интерпретатор, в котором пятый файловый дескриптор будет открыт и перенаправлен в STDOUT. И там можно сказать что-нибудь вроде `echo blah-blah >&5`, и оно выведется на STDOUT. 

> Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?

На экране нарисуется слово "netology". В этом примере мы напрямую записываем данные в пятый файловый дескриптор процесса с PIDом нашего текущего командного интерпретатора, который (дескриптор) уже перенаправлен в его же, интерпретатора, STDOUT.

> Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
> Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

Можно и с промежуточным дескриптором (cделаем сообщение об ошибке более эмоциональным):<br>
`ls /etc/passwd file_which_not_exist 3>&1 1>&2 2>&3 |tr 'a-z' 'A-Z'`

А можно и без промежуточного, с прямой записью в файловый дескриптор:<br>
`ls /etc/passwd file_which_not_exist 2>&1 1>/proc/$$/fd/1 |tr 'a-z' 'A-Z'`

> Что выведет команда `cat /proc/$$/environ`?

Она выведет переменные среды текущего командного интерпретатора, с нулевым символом в качестве разделителя вместо символа новых строк.
 
> Как еще можно получить аналогичный по содержанию вывод?

`env |tr '\n' '\0'`

> Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`

В man proc говорится, что в cmdline доступна полная командная строка вызова этого процесса, с аргументами, разделёнными нулевыми символами. Это файл будет пуст, если процесс - зомби.

> `/proc/<PID>/exe`.

В современных Линуксах это символьная ссылка, ссылающаяся на исполняемый файл данного процесса.

>Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

```
# cat /proc/cpuinfo |tr ' ' '\n' |grep "^sse" |sort -u |tail -1
sse4_2
```
> При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:<br>
> `ssh localhost 'tty'`<br>
> `not a tty`
> Почитайте, почему так происходит, и как изменить поведение.

ssh выделяет TTY при открытии логин-сессии. Если просто пытаться выполнить некую команду удалённо, TTY не выделяется. Это поведение можно изменить, запросив принудительное выделение TTY или ключом -t, или параметром  `RequestTTY=force`

> Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.
 
Попробовал. Работает :)  

> `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

`tee` вводит данные со своего стандартного ввода и выводит их одновременно в свой стандартный вывод и в файл, указанный в качестве параметра командной строки. Когда мы вызываем `sudo tee`, эта утилита исполняется с правами суперпользователя, и у неё есть достаточные права на запись файла, находящимся в домашней директории рута.